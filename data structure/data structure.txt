**********************************************************************************
Data Structure
    * คือแนวคิดการจัดการข้อมูล กับทุกภาษาโปรแกรมมิ่ง
    * ทำให้เข้าถึงข้อมูลได้อย่างรวดเร็ว

Types : แบ่งเป็น
        Linear  * ข้อมูลแต่ละตัวเรียงต่อกันแบบ"เส้นตรง"
                * เช่น Array, Linked List, Stack, Queue

        Non-Linear
                * ข้อมูลแต่ละตัวเรียงต่อกันแบบ"ไม่เป็นเส้นตรง"
                * เช่น Tree, Graph

**********************************************************************************
Array : 
        * เป็นโครงสร้างข้อมูลพื้นฐานที่ข้อมูลแต่ละตัวถูกเก็บไว้ ให้นึกถึง ซองใส่ซีดี 
        * ซองใส่ซีดี คือ Array
        * ช่องใส่ซีดี คือ Index ค่อยบอกตำแหน่งข้อมูล 
        * ซีดี คือ Data ที่เก็บเอาไว้

        EX.

        Array ซองใส่ซีดี = [a, s, d, f, g, h]
                          0  1  2  3  4  5  <--- Index

Linked List
        * เป็นโครงสร้างข้อมูลพื้นฐานที่ข้อมูลแต่ละตัวจะมี pointer ไว้ชี้ตำแหน่งข้อมูลตัวถัดไป
        * มีตัวตำแหน่งของ Head เอาไว้เพื่อบอกตำแหน่ง Head ของ Linked List
        * Types 2 แบบ
                1 เส้นตรง
                  Singly Linked : ชี้ตัวต่อไป  data:pointer
                  Doubly Linked : ชี้ตัวก่อนหน้า ชี้ตัวต่อไป pointer:data:pointer
                2 วงกลม (ใช้ได้ทั้ง Linked List , Queue)
                  Circular Linked List : ชี้ตัวต่อไป
                  Doubly Circular Linked List : ชี้ตัวก่อนหน้า

                โดยการเก็บข้อมูลจะเป็น [data:pointer]
        
         EX.
                Singly Linked
 
                Head
                [:1000]
                   |
                   |--> [a:1001]-->[b:1002]-->[c:1003]-->[d:null]
                          :1000      :1001      :1002      :1003

                Head อยู่ที่ :1000 
                a ตำแหน่งอยู่ที่ 1000 มี pointer ชี้ตำแหน่งต่อไปที่ 1001
                b ตำแหน่งอยู่ที่ 1001 มี pointer ชี้ตำแหน่งต่อไปที่ 1002
                c ตำแหน่งอยู่ที่ 1002 มี pointer ชี้ตำแหน่งต่อไปที่ 1003
                b ตำแหน่งอยู่ที่ 1003 มี pointer ชี้ตำแหน่งต่อไปที่ null 

                เมื่อตัวสุดท้ายชี้ไปที่ null แปลว่าสิ้นสุดและไม่มีตำแหน่งเก็บข้อมูลตัวต่อไปแล้ว
                ให้นึกถึง ขบวนรถไฟ ที่มีโบกี้ต่อๆไปกันโดยมีทางเชื่อมระหว่างโบกี้ คือ pointer
                ภายในโบกี้ก็จะมีสิ่งของที่ขนไปอยู่ คือ data ส่วนหัวรถไฟคือ Head นั้นเอง

Stack 
        * เป็นโครงสร้างข้อมูลแบบ last-in, first-out (LIFO) ของที่เพิ่งเข้าจะออกก่อนเสมอ
        * Push คือการนำข้อมูลเข้า Stack
        * Pop คือการนำข้อมูลออกจาก Stack

        EX.
                          |       ^
                          v       |
                |   |   | 3 |   |   |
                |   |   |   |   | 3 |
                | 2 |   | 2 |   | 2 |
                | 1 |   | 1 |   | 1 |
                -----   -----   -----
                         Push    Pop 

           ให้นึกถึงเกม หอคอยฮานอย

Queue
        * เป็นโครงสร้างข้อมูลแบบ first-in, first-out (FIFO) ของที่เข้าไปก่อนจะออกก่อนเสมอ
        * Enqueue คือการนำข้อมูลเข้านำ Queue
        * Dequeue คือการนำข้อมูลออกจาก Queue

        ______               ______        ______

             1      ----> 2        1          2,1   ----> 
        ______               ______        ______
                             Enqueue       Dequeue

        ให้นึกถึง การรอคิว หรือ ดูดชานมไข่มุก มุกที่เข้าหลอดอันแรกจะเข้าปากก่อน "อร่อยยยยย"


Tree
        * เป็นโครงสร้างข้อมูลแบบต้นไม้ เพื่อแบ่งข้อมูลเป็นหมวดหมู่ตามมกิ่งกานของต้นไม้ (ต้นไม้กลับหัว)
        * มีจุดเริ่มต้นจาก root และแตก branch ไปยังแต่ละ node

        EX. Binary Tree


                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7

        ข้อมูลจะเรียงตัวเหมือนต้นไม้ที่กลับหัว โดยตัวซ้ายสุดที่เป็นตัวสุดท้าย(7) จะเรียกว่า Leaf node
        ส่วนที่เชื่อมระหว่าง node เริยกว่า Edge 


        Tree Traversal
                1. Breadth-First Traversql (BFT)
                        * เจอตัวไหนก่อนpopตัวนั้น ตามลำดับราชวงศ์

                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7
                                               / \
                                              /   \
                                             8     9

                        Output : 4 2 6 1 3 5 7 8 9

                2. Depth=First Traversal (DFT)
                        * Node node ไป node ลูกก่อนจนไม่มี node ค่อยขึ้นมา ใช้กับ Stack

                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7
                                               / \
                                              /   \
                                             8     9

                        Output : 1 3 2 5 8 9 7 6 4

                        * preorder (ซ้าย --> ขวา)

                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7
                                               / \
                                              /   \
                                             8     9

                        Output : 4 2 1 3 6 5 7 8 9

                        * inorder (ซ้ายสุดก่อน --> ขวา)
        
                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7
                                               / \
                                              /   \
                                             8     9

                        Output : 1 2 3 4 5 6 8 7 9

                        * postorder (Lv ต่ำสุด ซ้ายก่อน)

                                        4   <---- root
                                      /   \
                                     /     \
                                    /       \
                                   2         6
                                  / \       / \  <--- Edge
                                 /   \     /   \
                                1     3   5     7
                                               / \
                                              /   \
                                             8     9

                        Output : 1 3 2 5 8 9 7 6 4


Graph
        * เป็นโครงสร้างข้อมูลแบบ Graph โดยที่มีการเชื่อต่อระหว่าง vertices (node) ด้วย Edge
        * สามารถนำไปเปรียบเทียบกับจุดต่างๆ บนแผนที่ และถนนที่เชื่อมต่อกันได้

        EX. Graph

                        2 ------- 3 
                       /          |\
                      /           | \ <---- Edge
                     /            |  \
                    1             |   6  <---- vertices (node)
                     \            |  / 
                      \           | /   
                       \          |/ 
                        4 ------- 5  <---- vertices (node)

                ให้นึกถึง ถนนนิมมานที่มีซอยทะลุหากัน

**********************************************************************************

